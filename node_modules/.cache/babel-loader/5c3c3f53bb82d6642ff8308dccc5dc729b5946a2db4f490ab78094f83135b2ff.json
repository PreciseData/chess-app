{"ast":null,"code":"/**\n * AI player for chess game\n * Implements a simple minimax algorithm with alpha-beta pruning\n * Enhanced with AI personalities and adaptive difficulty\n */\n\nimport { isValidMove, wouldBeInCheck, isCheckmate, isStalemate, isSquareAttacked } from './chessRules';\nimport { AI_PERSONALITIES } from './aiPersonalities';\n\n// Default piece values for evaluation\nconst DEFAULT_PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// Position bonuses to encourage good piece positioning\nconst POSITION_BONUSES = {\n  pawn: [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5], [0.5, 1, 1, -2, -2, 1, 1, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]],\n  knight: [[-5, -4, -3, -3, -3, -3, -4, -5], [-4, -2, 0, 0, 0, 0, -2, -4], [-3, 0, 1, 1.5, 1.5, 1, 0, -3], [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3], [-3, 0, 1.5, 2, 2, 1.5, 0, -3], [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3], [-4, -2, 0, 0.5, 0.5, 0, -2, -4], [-5, -4, -3, -3, -3, -3, -4, -5]],\n  bishop: [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]],\n  rook: [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]],\n  queen: [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]],\n  king: [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]]\n};\n\n// Evaluate the board position from the perspective of the given color\nexport const evaluateBoard = (board, color, personality = 'standard') => {\n  // Get the AI personality or use standard if not found\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  const pieceValues = aiPersonality.pieceValues || DEFAULT_PIECE_VALUES;\n  let score = 0;\n\n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        // Material value based on personality\n        const materialValue = pieceValues[piece.type] || DEFAULT_PIECE_VALUES[piece.type];\n\n        // Position bonus\n        let positionBonus = 0;\n        if (POSITION_BONUSES[piece.type]) {\n          // For black pieces, we need to flip the position matrix\n          const positionRow = piece.color === 'white' ? row : 7 - row;\n          positionBonus = POSITION_BONUSES[piece.type][positionRow][col];\n        }\n\n        // Add or subtract based on piece color\n        const value = materialValue + positionBonus;\n        if (piece.color === color) {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n\n  // Apply personality-specific evaluation modifier\n  if (aiPersonality.evaluationModifier) {\n    score = aiPersonality.evaluationModifier(board, color, score);\n  }\n  return score;\n};\n\n// Get all valid moves for a given color\nexport const getAllValidMoves = (board, color, castlingRights, lastMove) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, color)) {\n                // Check if this is a capture move\n                const capturedPiece = board[toRow][toCol];\n                moves.push({\n                  fromRow,\n                  fromCol,\n                  toRow,\n                  toCol,\n                  piece,\n                  capturedPiece\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Make a move on a copy of the board\nexport const makeMove = (board, move) => {\n  const newBoard = board.map(row => [...row]);\n  newBoard[move.toRow][move.toCol] = newBoard[move.fromRow][move.fromCol];\n  newBoard[move.fromRow][move.fromCol] = null;\n  return newBoard;\n};\n\n// Minimax algorithm with alpha-beta pruning\nexport const minimax = (board, depth, alpha, beta, maximizingPlayer, color, castlingRights, lastMove, personality = 'standard') => {\n  // Base case: reached maximum depth or game over\n  if (depth === 0) {\n    return {\n      score: evaluateBoard(board, color, personality)\n    };\n  }\n  const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n\n  // Check for checkmate or stalemate\n  if (isCheckmate(board, currentColor, castlingRights, lastMove)) {\n    return {\n      score: maximizingPlayer ? -10000 : 10000\n    };\n  }\n  if (isStalemate(board, currentColor, castlingRights, lastMove)) {\n    return {\n      score: 0\n    };\n  }\n  let moves = getAllValidMoves(board, currentColor, castlingRights, lastMove);\n\n  // No valid moves\n  if (moves.length === 0) {\n    return {\n      score: evaluateBoard(board, color, personality)\n    };\n  }\n\n  // Apply personality-specific move preferences\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  if (aiPersonality.movePreference) {\n    moves = aiPersonality.movePreference(moves);\n  }\n  let bestMove = null;\n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, false, color, castlingRights, move, personality);\n      if (evalResult.score > maxEval) {\n        maxEval = evalResult.score;\n        bestMove = move;\n      }\n      alpha = Math.max(alpha, evalResult.score);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    return {\n      move: bestMove,\n      score: maxEval\n    };\n  } else {\n    let minEval = Infinity;\n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, true, color, castlingRights, move, personality);\n      if (evalResult.score < minEval) {\n        minEval = evalResult.score;\n        bestMove = move;\n      }\n      beta = Math.min(beta, evalResult.score);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    return {\n      move: bestMove,\n      score: minEval\n    };\n  }\n};\n\n// Get the best move for the AI\nexport const getBestMove = (board, color, castlingRights, lastMove, difficulty = 'medium', personality = 'standard') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 2;\n      break;\n    case 'medium':\n      depth = 3;\n      break;\n    case 'hard':\n      depth = 4;\n      break;\n    default:\n      depth = 3;\n  }\n\n  // Apply personality difficulty multiplier\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  if (aiPersonality.difficultyMultiplier) {\n    depth = Math.max(1, Math.round(depth * aiPersonality.difficultyMultiplier));\n  }\n\n  // Use minimax to find the best move\n  const result = minimax(board, depth, -Infinity, Infinity, true, color, castlingRights, lastMove, personality);\n  return result.move;\n};","map":{"version":3,"names":["isValidMove","wouldBeInCheck","isCheckmate","isStalemate","isSquareAttacked","AI_PERSONALITIES","DEFAULT_PIECE_VALUES","pawn","knight","bishop","rook","queen","king","POSITION_BONUSES","evaluateBoard","board","color","personality","aiPersonality","standard","pieceValues","score","row","col","piece","materialValue","type","positionBonus","positionRow","value","evaluationModifier","getAllValidMoves","castlingRights","lastMove","moves","fromRow","fromCol","toRow","toCol","capturedPiece","push","makeMove","move","newBoard","map","minimax","depth","alpha","beta","maximizingPlayer","currentColor","length","movePreference","bestMove","maxEval","Infinity","evalResult","Math","max","minEval","min","getBestMove","difficulty","difficultyMultiplier","round","result"],"sources":["C:/Users/aksha/AppData/Local/Programs/Microsoft VS Code/chess-app/src/utils/aiPlayer.js"],"sourcesContent":["/**\n * AI player for chess game\n * Implements a simple minimax algorithm with alpha-beta pruning\n * Enhanced with AI personalities and adaptive difficulty\n */\n\nimport { isValidMove, wouldBeInCheck, isCheckmate, isStalemate, isSquareAttacked } from './chessRules';\nimport { AI_PERSONALITIES } from './aiPersonalities';\n\n// Default piece values for evaluation\nconst DEFAULT_PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// Position bonuses to encourage good piece positioning\nconst POSITION_BONUSES = {\n  pawn: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  knight: [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  bishop: [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  rook: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  queen: [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  king: [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Evaluate the board position from the perspective of the given color\nexport const evaluateBoard = (board, color, personality = 'standard') => {\n  // Get the AI personality or use standard if not found\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  const pieceValues = aiPersonality.pieceValues || DEFAULT_PIECE_VALUES;\n  \n  let score = 0;\n  \n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        // Material value based on personality\n        const materialValue = pieceValues[piece.type] || DEFAULT_PIECE_VALUES[piece.type];\n        \n        // Position bonus\n        let positionBonus = 0;\n        if (POSITION_BONUSES[piece.type]) {\n          // For black pieces, we need to flip the position matrix\n          const positionRow = piece.color === 'white' ? row : 7 - row;\n          positionBonus = POSITION_BONUSES[piece.type][positionRow][col];\n        }\n        \n        // Add or subtract based on piece color\n        const value = materialValue + positionBonus;\n        if (piece.color === color) {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  \n  // Apply personality-specific evaluation modifier\n  if (aiPersonality.evaluationModifier) {\n    score = aiPersonality.evaluationModifier(board, color, score);\n  }\n  \n  return score;\n};\n\n// Get all valid moves for a given color\nexport const getAllValidMoves = (board, color, castlingRights, lastMove) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, color)) {\n                // Check if this is a capture move\n                const capturedPiece = board[toRow][toCol];\n                \n                moves.push({\n                  fromRow,\n                  fromCol,\n                  toRow,\n                  toCol,\n                  piece,\n                  capturedPiece\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Make a move on a copy of the board\nexport const makeMove = (board, move) => {\n  const newBoard = board.map(row => [...row]);\n  newBoard[move.toRow][move.toCol] = newBoard[move.fromRow][move.fromCol];\n  newBoard[move.fromRow][move.fromCol] = null;\n  return newBoard;\n};\n\n// Minimax algorithm with alpha-beta pruning\nexport const minimax = (board, depth, alpha, beta, maximizingPlayer, color, castlingRights, lastMove, personality = 'standard') => {\n  // Base case: reached maximum depth or game over\n  if (depth === 0) {\n    return { score: evaluateBoard(board, color, personality) };\n  }\n  \n  const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n  \n  // Check for checkmate or stalemate\n  if (isCheckmate(board, currentColor, castlingRights, lastMove)) {\n    return { score: maximizingPlayer ? -10000 : 10000 };\n  }\n  \n  if (isStalemate(board, currentColor, castlingRights, lastMove)) {\n    return { score: 0 };\n  }\n  \n  let moves = getAllValidMoves(board, currentColor, castlingRights, lastMove);\n  \n  // No valid moves\n  if (moves.length === 0) {\n    return { score: evaluateBoard(board, color, personality) };\n  }\n  \n  // Apply personality-specific move preferences\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  if (aiPersonality.movePreference) {\n    moves = aiPersonality.movePreference(moves);\n  }\n  \n  let bestMove = null;\n  \n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    \n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, false, color, castlingRights, move, personality);\n      \n      if (evalResult.score > maxEval) {\n        maxEval = evalResult.score;\n        bestMove = move;\n      }\n      \n      alpha = Math.max(alpha, evalResult.score);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    \n    return { move: bestMove, score: maxEval };\n  } else {\n    let minEval = Infinity;\n    \n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, true, color, castlingRights, move, personality);\n      \n      if (evalResult.score < minEval) {\n        minEval = evalResult.score;\n        bestMove = move;\n      }\n      \n      beta = Math.min(beta, evalResult.score);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    \n    return { move: bestMove, score: minEval };\n  }\n};\n\n// Get the best move for the AI\nexport const getBestMove = (board, color, castlingRights, lastMove, difficulty = 'medium', personality = 'standard') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 2;\n      break;\n    case 'medium':\n      depth = 3;\n      break;\n    case 'hard':\n      depth = 4;\n      break;\n    default:\n      depth = 3;\n  }\n  \n  // Apply personality difficulty multiplier\n  const aiPersonality = AI_PERSONALITIES[personality] || AI_PERSONALITIES.standard;\n  if (aiPersonality.difficultyMultiplier) {\n    depth = Math.max(1, Math.round(depth * aiPersonality.difficultyMultiplier));\n  }\n  \n  // Use minimax to find the best move\n  const result = minimax(board, depth, -Infinity, Infinity, true, color, castlingRights, lastMove, personality);\n  return result.move;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}