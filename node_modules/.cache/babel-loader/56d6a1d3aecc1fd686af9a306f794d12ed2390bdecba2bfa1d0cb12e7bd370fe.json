{"ast":null,"code":"/**\n * AI Personalities for Chess\n * Different AI playing styles with unique evaluation functions and move preferences\n */\n\n// Base evaluation weights used by all personalities\nconst BASE_PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// AI Personality definitions\nexport const AI_PERSONALITIES = {\n  // Standard balanced AI (default)\n  standard: {\n    name: \"Standard\",\n    description: \"A balanced AI that plays conventional chess\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES\n    },\n    // Standard personality doesn't modify the base evaluation\n    evaluationModifier: (board, color, baseEvaluation) => baseEvaluation,\n    // No move preference bias\n    movePreference: moves => moves,\n    difficultyMultiplier: 1.0\n  },\n  // Aggressive AI that prioritizes attacks and captures\n  aggressive: {\n    name: \"Aggressive\",\n    description: \"Prioritizes attacking and capturing opponent pieces\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES,\n      // Values attacking pieces more highly\n      knight: 32,\n      bishop: 32,\n      rook: 55,\n      queen: 95\n    },\n    // Rewards positions with more potential attacks\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let attackBonus = 0;\n\n      // Count attacks on opponent pieces\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          const piece = board[row][col];\n          if (piece && piece.color !== color) {\n            // Check if this opponent piece is under attack\n            if (isSquareAttacked(board, row, col, piece.color)) {\n              attackBonus += getPieceValue(piece.type) * 0.2;\n            }\n          }\n        }\n      }\n      return baseEvaluation + attackBonus;\n    },\n    // Prefers capturing moves and moves that put pieces in attacking positions\n    movePreference: moves => {\n      return moves.sort((a, b) => {\n        // Prioritize captures\n        const aIsCapture = a.capturedPiece != null;\n        const bIsCapture = b.capturedPiece != null;\n        if (aIsCapture && !bIsCapture) return -1;\n        if (!aIsCapture && bIsCapture) return 1;\n\n        // If both are captures, prioritize higher value captures\n        if (aIsCapture && bIsCapture) {\n          const aValue = getPieceValue(a.capturedPiece.type);\n          const bValue = getPieceValue(b.capturedPiece.type);\n          return bValue - aValue; // Higher value first\n        }\n        return 0;\n      });\n    },\n    difficultyMultiplier: 1.1 // Slightly more challenging\n  },\n  // Defensive AI that prioritizes protection and safety\n  defensive: {\n    name: \"Defensive\",\n    description: \"Focuses on protecting pieces and building a solid position\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES,\n      // Values defensive pieces more\n      pawn: 12,\n      // Pawns are important for defense\n      bishop: 28,\n      knight: 28,\n      king: 950 // King safety is paramount\n    },\n    // Rewards positions with better piece protection\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let defenseBonus = 0;\n\n      // Reward protected pieces\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          const piece = board[row][col];\n          if (piece && piece.color === color) {\n            // Check if this piece is protected by another piece\n            if (isSquareProtected(board, row, col, color)) {\n              defenseBonus += getPieceValue(piece.type) * 0.1;\n            }\n\n            // Penalize exposed pieces\n            if (isSquareAttacked(board, row, col, piece.color) && !isSquareProtected(board, row, col, color)) {\n              defenseBonus -= getPieceValue(piece.type) * 0.15;\n            }\n          }\n        }\n      }\n\n      // Bonus for keeping the king protected\n      const kingPosition = findKing(board, color);\n      if (kingPosition) {\n        const [kingRow, kingCol] = kingPosition;\n\n        // Reward pawn shield in front of king\n        const pawnDirection = color === 'white' ? -1 : 1;\n        for (let offset = -1; offset <= 1; offset++) {\n          const shieldCol = kingCol + offset;\n          if (shieldCol >= 0 && shieldCol < 8) {\n            const shieldRow = kingRow + pawnDirection;\n            if (shieldRow >= 0 && shieldRow < 8 && board[shieldRow][shieldCol] && board[shieldRow][shieldCol].type === 'pawn' && board[shieldRow][shieldCol].color === color) {\n              defenseBonus += 5;\n            }\n          }\n        }\n      }\n      return baseEvaluation + defenseBonus;\n    },\n    // Prefers moves that protect pieces or improve king safety\n    movePreference: moves => {\n      return moves.sort((a, b) => {\n        // Avoid captures if possible (don't trade)\n        const aIsCapture = a.capturedPiece != null;\n        const bIsCapture = b.capturedPiece != null;\n        if (!aIsCapture && bIsCapture) return -1;\n        if (aIsCapture && !bIsCapture) return 1;\n        return 0;\n      });\n    },\n    difficultyMultiplier: 1.0\n  },\n  // Positional AI that focuses on board control and piece coordination\n  positional: {\n    name: \"Positional\",\n    description: \"Emphasizes board control and piece coordination\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES\n    },\n    // Rewards control of the center and good piece positioning\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let positionBonus = 0;\n\n      // Bonus for controlling center squares\n      const centerSquares = [[3, 3], [3, 4], [4, 3], [4, 4]];\n      for (const [row, col] of centerSquares) {\n        const piece = board[row][col];\n        if (piece && piece.color === color) {\n          positionBonus += 5;\n        }\n\n        // Also count attacks on center squares\n        if (isSquareAttacked(board, row, col, color === 'white' ? 'black' : 'white')) {\n          positionBonus += 2;\n        }\n      }\n\n      // Bonus for developed pieces (not in starting position)\n      const backRank = color === 'white' ? 7 : 0;\n      for (let col = 0; col < 8; col++) {\n        const piece = board[backRank][col];\n        if (piece && piece.color === color && (piece.type === 'knight' || piece.type === 'bishop')) {\n          // Penalize undeveloped minor pieces\n          positionBonus -= 5;\n        }\n      }\n      return baseEvaluation + positionBonus;\n    },\n    // Prefers moves that develop pieces and control the center\n    movePreference: moves => {\n      return moves.sort((a, b) => {\n        // Prefer moves toward the center\n        const aCenterDistance = getCenterDistance(a.toRow, a.toCol);\n        const bCenterDistance = getCenterDistance(b.toRow, b.toCol);\n        return aCenterDistance - bCenterDistance; // Lower distance first\n      });\n    },\n    difficultyMultiplier: 1.2 // More challenging\n  },\n  // Creative AI that makes unexpected moves\n  creative: {\n    name: \"Creative\",\n    description: \"Makes unexpected and surprising moves\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES,\n      knight: 33,\n      // Values knights more for their unpredictable movement\n      bishop: 29\n    },\n    // Occasionally introduces randomness to evaluation\n    evaluationModifier: (board, color, baseEvaluation) => {\n      // Add some controlled randomness to the evaluation\n      const randomFactor = (Math.random() - 0.5) * 10;\n      return baseEvaluation + randomFactor;\n    },\n    // Occasionally chooses a random move from the top moves\n    movePreference: moves => {\n      // 20% chance to pick a random move from the top half of moves\n      if (Math.random() < 0.2 && moves.length > 1) {\n        const midpoint = Math.floor(moves.length / 2);\n        const topMoves = moves.slice(0, midpoint);\n        const randomIndex = Math.floor(Math.random() * topMoves.length);\n\n        // Move the randomly selected move to the front\n        const randomMove = topMoves[randomIndex];\n        moves.splice(moves.indexOf(randomMove), 1);\n        moves.unshift(randomMove);\n      }\n      return moves;\n    },\n    difficultyMultiplier: 1.0\n  },\n  // Beginner-friendly AI that makes occasional mistakes\n  beginner: {\n    name: \"Beginner\",\n    description: \"Makes occasional mistakes, suitable for new players\",\n    pieceValues: {\n      ...BASE_PIECE_VALUES\n    },\n    // Occasionally undervalues pieces\n    evaluationModifier: (board, color, baseEvaluation) => {\n      // 30% chance to miscalculate evaluation\n      if (Math.random() < 0.3) {\n        return baseEvaluation * (0.7 + Math.random() * 0.3); // 70-100% of actual value\n      }\n      return baseEvaluation;\n    },\n    // Occasionally makes suboptimal moves\n    movePreference: moves => {\n      // 25% chance to pick a suboptimal move\n      if (Math.random() < 0.25 && moves.length > 3) {\n        const midpoint = Math.floor(moves.length / 2);\n        const suboptimalMoves = moves.slice(midpoint);\n        const randomIndex = Math.floor(Math.random() * suboptimalMoves.length);\n\n        // Move a suboptimal move to the front\n        const randomMove = suboptimalMoves[randomIndex];\n        moves.splice(moves.indexOf(randomMove), 1);\n        moves.unshift(randomMove);\n      }\n      return moves;\n    },\n    difficultyMultiplier: 0.7 // Easier\n  }\n};\n\n// Helper functions\n\n// Get the value of a piece type\nfunction getPieceValue(pieceType) {\n  return BASE_PIECE_VALUES[pieceType] || 0;\n}\n\n// Check if a square is attacked by any piece of the given color\nfunction isSquareAttacked(board, row, col, defendingColor) {\n  // Implementation would be similar to the one in chessRules.js\n  // This is a simplified placeholder\n  return false;\n}\n\n// Check if a square is protected by any piece of the given color\nfunction isSquareProtected(board, row, col, color) {\n  // Implementation would be similar to isSquareAttacked but for friendly pieces\n  // This is a simplified placeholder\n  return false;\n}\n\n// Find the king of the given color\nfunction findKing(board, color) {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return [row, col];\n      }\n    }\n  }\n  return null;\n}\n\n// Calculate distance from a square to the center of the board\nfunction getCenterDistance(row, col) {\n  const centerRow = 3.5;\n  const centerCol = 3.5;\n  return Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2));\n}","map":{"version":3,"names":["BASE_PIECE_VALUES","pawn","knight","bishop","rook","queen","king","AI_PERSONALITIES","standard","name","description","pieceValues","evaluationModifier","board","color","baseEvaluation","movePreference","moves","difficultyMultiplier","aggressive","attackBonus","row","col","piece","isSquareAttacked","getPieceValue","type","sort","a","b","aIsCapture","capturedPiece","bIsCapture","aValue","bValue","defensive","defenseBonus","isSquareProtected","kingPosition","findKing","kingRow","kingCol","pawnDirection","offset","shieldCol","shieldRow","positional","positionBonus","centerSquares","backRank","aCenterDistance","getCenterDistance","toRow","toCol","bCenterDistance","creative","randomFactor","Math","random","length","midpoint","floor","topMoves","slice","randomIndex","randomMove","splice","indexOf","unshift","beginner","suboptimalMoves","pieceType","defendingColor","centerRow","centerCol","sqrt","pow"],"sources":["C:/Users/aksha/AppData/Local/Programs/Microsoft VS Code/chess-app/src/utils/aiPersonalities.js"],"sourcesContent":["/**\n * AI Personalities for Chess\n * Different AI playing styles with unique evaluation functions and move preferences\n */\n\n// Base evaluation weights used by all personalities\nconst BASE_PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// AI Personality definitions\nexport const AI_PERSONALITIES = {\n  // Standard balanced AI (default)\n  standard: {\n    name: \"Standard\",\n    description: \"A balanced AI that plays conventional chess\",\n    pieceValues: { ...BASE_PIECE_VALUES },\n    // Standard personality doesn't modify the base evaluation\n    evaluationModifier: (board, color, baseEvaluation) => baseEvaluation,\n    // No move preference bias\n    movePreference: (moves) => moves,\n    difficultyMultiplier: 1.0\n  },\n  \n  // Aggressive AI that prioritizes attacks and captures\n  aggressive: {\n    name: \"Aggressive\",\n    description: \"Prioritizes attacking and capturing opponent pieces\",\n    pieceValues: { \n      ...BASE_PIECE_VALUES,\n      // Values attacking pieces more highly\n      knight: 32,\n      bishop: 32,\n      rook: 55,\n      queen: 95\n    },\n    // Rewards positions with more potential attacks\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let attackBonus = 0;\n      \n      // Count attacks on opponent pieces\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          const piece = board[row][col];\n          if (piece && piece.color !== color) {\n            // Check if this opponent piece is under attack\n            if (isSquareAttacked(board, row, col, piece.color)) {\n              attackBonus += getPieceValue(piece.type) * 0.2;\n            }\n          }\n        }\n      }\n      \n      return baseEvaluation + attackBonus;\n    },\n    // Prefers capturing moves and moves that put pieces in attacking positions\n    movePreference: (moves) => {\n      return moves.sort((a, b) => {\n        // Prioritize captures\n        const aIsCapture = a.capturedPiece != null;\n        const bIsCapture = b.capturedPiece != null;\n        \n        if (aIsCapture && !bIsCapture) return -1;\n        if (!aIsCapture && bIsCapture) return 1;\n        \n        // If both are captures, prioritize higher value captures\n        if (aIsCapture && bIsCapture) {\n          const aValue = getPieceValue(a.capturedPiece.type);\n          const bValue = getPieceValue(b.capturedPiece.type);\n          return bValue - aValue; // Higher value first\n        }\n        \n        return 0;\n      });\n    },\n    difficultyMultiplier: 1.1 // Slightly more challenging\n  },\n  \n  // Defensive AI that prioritizes protection and safety\n  defensive: {\n    name: \"Defensive\",\n    description: \"Focuses on protecting pieces and building a solid position\",\n    pieceValues: { \n      ...BASE_PIECE_VALUES,\n      // Values defensive pieces more\n      pawn: 12, // Pawns are important for defense\n      bishop: 28,\n      knight: 28,\n      king: 950 // King safety is paramount\n    },\n    // Rewards positions with better piece protection\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let defenseBonus = 0;\n      \n      // Reward protected pieces\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          const piece = board[row][col];\n          if (piece && piece.color === color) {\n            // Check if this piece is protected by another piece\n            if (isSquareProtected(board, row, col, color)) {\n              defenseBonus += getPieceValue(piece.type) * 0.1;\n            }\n            \n            // Penalize exposed pieces\n            if (isSquareAttacked(board, row, col, piece.color) && \n                !isSquareProtected(board, row, col, color)) {\n              defenseBonus -= getPieceValue(piece.type) * 0.15;\n            }\n          }\n        }\n      }\n      \n      // Bonus for keeping the king protected\n      const kingPosition = findKing(board, color);\n      if (kingPosition) {\n        const [kingRow, kingCol] = kingPosition;\n        \n        // Reward pawn shield in front of king\n        const pawnDirection = color === 'white' ? -1 : 1;\n        for (let offset = -1; offset <= 1; offset++) {\n          const shieldCol = kingCol + offset;\n          if (shieldCol >= 0 && shieldCol < 8) {\n            const shieldRow = kingRow + pawnDirection;\n            if (shieldRow >= 0 && shieldRow < 8 && \n                board[shieldRow][shieldCol] && \n                board[shieldRow][shieldCol].type === 'pawn' && \n                board[shieldRow][shieldCol].color === color) {\n              defenseBonus += 5;\n            }\n          }\n        }\n      }\n      \n      return baseEvaluation + defenseBonus;\n    },\n    // Prefers moves that protect pieces or improve king safety\n    movePreference: (moves) => {\n      return moves.sort((a, b) => {\n        // Avoid captures if possible (don't trade)\n        const aIsCapture = a.capturedPiece != null;\n        const bIsCapture = b.capturedPiece != null;\n        \n        if (!aIsCapture && bIsCapture) return -1;\n        if (aIsCapture && !bIsCapture) return 1;\n        \n        return 0;\n      });\n    },\n    difficultyMultiplier: 1.0\n  },\n  \n  // Positional AI that focuses on board control and piece coordination\n  positional: {\n    name: \"Positional\",\n    description: \"Emphasizes board control and piece coordination\",\n    pieceValues: { ...BASE_PIECE_VALUES },\n    // Rewards control of the center and good piece positioning\n    evaluationModifier: (board, color, baseEvaluation) => {\n      let positionBonus = 0;\n      \n      // Bonus for controlling center squares\n      const centerSquares = [\n        [3, 3], [3, 4], [4, 3], [4, 4]\n      ];\n      \n      for (const [row, col] of centerSquares) {\n        const piece = board[row][col];\n        if (piece && piece.color === color) {\n          positionBonus += 5;\n        }\n        \n        // Also count attacks on center squares\n        if (isSquareAttacked(board, row, col, color === 'white' ? 'black' : 'white')) {\n          positionBonus += 2;\n        }\n      }\n      \n      // Bonus for developed pieces (not in starting position)\n      const backRank = color === 'white' ? 7 : 0;\n      for (let col = 0; col < 8; col++) {\n        const piece = board[backRank][col];\n        if (piece && piece.color === color && \n            (piece.type === 'knight' || piece.type === 'bishop')) {\n          // Penalize undeveloped minor pieces\n          positionBonus -= 5;\n        }\n      }\n      \n      return baseEvaluation + positionBonus;\n    },\n    // Prefers moves that develop pieces and control the center\n    movePreference: (moves) => {\n      return moves.sort((a, b) => {\n        // Prefer moves toward the center\n        const aCenterDistance = getCenterDistance(a.toRow, a.toCol);\n        const bCenterDistance = getCenterDistance(b.toRow, b.toCol);\n        \n        return aCenterDistance - bCenterDistance; // Lower distance first\n      });\n    },\n    difficultyMultiplier: 1.2 // More challenging\n  },\n  \n  // Creative AI that makes unexpected moves\n  creative: {\n    name: \"Creative\",\n    description: \"Makes unexpected and surprising moves\",\n    pieceValues: { \n      ...BASE_PIECE_VALUES,\n      knight: 33, // Values knights more for their unpredictable movement\n      bishop: 29\n    },\n    // Occasionally introduces randomness to evaluation\n    evaluationModifier: (board, color, baseEvaluation) => {\n      // Add some controlled randomness to the evaluation\n      const randomFactor = (Math.random() - 0.5) * 10;\n      return baseEvaluation + randomFactor;\n    },\n    // Occasionally chooses a random move from the top moves\n    movePreference: (moves) => {\n      // 20% chance to pick a random move from the top half of moves\n      if (Math.random() < 0.2 && moves.length > 1) {\n        const midpoint = Math.floor(moves.length / 2);\n        const topMoves = moves.slice(0, midpoint);\n        const randomIndex = Math.floor(Math.random() * topMoves.length);\n        \n        // Move the randomly selected move to the front\n        const randomMove = topMoves[randomIndex];\n        moves.splice(moves.indexOf(randomMove), 1);\n        moves.unshift(randomMove);\n      }\n      \n      return moves;\n    },\n    difficultyMultiplier: 1.0\n  },\n  \n  // Beginner-friendly AI that makes occasional mistakes\n  beginner: {\n    name: \"Beginner\",\n    description: \"Makes occasional mistakes, suitable for new players\",\n    pieceValues: { ...BASE_PIECE_VALUES },\n    // Occasionally undervalues pieces\n    evaluationModifier: (board, color, baseEvaluation) => {\n      // 30% chance to miscalculate evaluation\n      if (Math.random() < 0.3) {\n        return baseEvaluation * (0.7 + Math.random() * 0.3); // 70-100% of actual value\n      }\n      return baseEvaluation;\n    },\n    // Occasionally makes suboptimal moves\n    movePreference: (moves) => {\n      // 25% chance to pick a suboptimal move\n      if (Math.random() < 0.25 && moves.length > 3) {\n        const midpoint = Math.floor(moves.length / 2);\n        const suboptimalMoves = moves.slice(midpoint);\n        const randomIndex = Math.floor(Math.random() * suboptimalMoves.length);\n        \n        // Move a suboptimal move to the front\n        const randomMove = suboptimalMoves[randomIndex];\n        moves.splice(moves.indexOf(randomMove), 1);\n        moves.unshift(randomMove);\n      }\n      \n      return moves;\n    },\n    difficultyMultiplier: 0.7 // Easier\n  }\n};\n\n// Helper functions\n\n// Get the value of a piece type\nfunction getPieceValue(pieceType) {\n  return BASE_PIECE_VALUES[pieceType] || 0;\n}\n\n// Check if a square is attacked by any piece of the given color\nfunction isSquareAttacked(board, row, col, defendingColor) {\n  // Implementation would be similar to the one in chessRules.js\n  // This is a simplified placeholder\n  return false;\n}\n\n// Check if a square is protected by any piece of the given color\nfunction isSquareProtected(board, row, col, color) {\n  // Implementation would be similar to isSquareAttacked but for friendly pieces\n  // This is a simplified placeholder\n  return false;\n}\n\n// Find the king of the given color\nfunction findKing(board, color) {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return [row, col];\n      }\n    }\n  }\n  return null;\n}\n\n// Calculate distance from a square to the center of the board\nfunction getCenterDistance(row, col) {\n  const centerRow = 3.5;\n  const centerCol = 3.5;\n  return Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}