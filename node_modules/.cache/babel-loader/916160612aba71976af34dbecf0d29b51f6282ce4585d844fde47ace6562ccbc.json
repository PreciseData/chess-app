{"ast":null,"code":"/**\n * Chess rules utility functions\n * Handles move validation, special moves, and game state checks\n */\n\n// Check if a move is valid based on piece type and chess rules\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n\n  // Cannot capture own piece\n  if (board[toRow][toCol] && board[toRow][toCol].color === piece.color) {\n    return false;\n  }\n\n  // Check specific piece movement rules\n  switch (piece.type) {\n    case 'pawn':\n      return isValidPawnMove(board, fromRow, fromCol, toRow, toCol);\n    case 'rook':\n      return isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n    case 'knight':\n      return isValidKnightMove(fromRow, fromCol, toRow, toCol);\n    case 'bishop':\n      return isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n    case 'queen':\n      return isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n    case 'king':\n      return isValidKingMove(board, fromRow, fromCol, toRow, toCol);\n    default:\n      return false;\n  }\n};\n\n// Pawn movement validation including en passant\nexport const isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, lastMove = null) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1; // White moves up (-1), black moves down (+1)\n\n  // Regular move forward\n  if (fromCol === toCol && board[toRow][toCol] === null) {\n    // Move one square forward\n    if (toRow === fromRow + direction) {\n      return true;\n    }\n\n    // Move two squares forward from starting position\n    const startingRow = piece.color === 'white' ? 6 : 1;\n    if (fromRow === startingRow && toRow === fromRow + 2 * direction && board[fromRow + direction][fromCol] === null) {\n      return true;\n    }\n  }\n\n  // Capture diagonally\n  if (toRow === fromRow + direction && Math.abs(toCol - fromCol) === 1) {\n    // Regular capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n\n    // En passant capture\n    if (lastMove && lastMove.piece.type === 'pawn' && lastMove.to.row === fromRow && lastMove.to.col === toCol && Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Rook movement validation\nexport const isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rook can only move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n\n  // Check if path is clear\n  return isPathClear(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Knight movement validation\nexport const isValidKnightMove = (fromRow, fromCol, toRow, toCol) => {\n  // Knight moves in L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  return rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2;\n};\n\n// Bishop movement validation\nexport const isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishop can only move diagonally\n  if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) {\n    return false;\n  }\n\n  // Check if path is clear\n  return isPathClear(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Queen movement validation\nexport const isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queen can move like a rook or a bishop\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// King movement validation including castling\nexport const isValidKingMove = (board, fromRow, fromCol, toRow, toCol, castlingRights = null, inCheck = false) => {\n  // Regular king move (one square in any direction)\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n\n  // Castling\n  if (castlingRights && !inCheck && rowDiff === 0 && colDiff === 2) {\n    const piece = board[fromRow][fromCol];\n\n    // Kingside castling\n    if (toCol === fromCol + 2 && (piece.color === 'white' && castlingRights.whiteKingside || piece.color === 'black' && castlingRights.blackKingside)) {\n      // Check if path is clear\n      return board[fromRow][fromCol + 1] === null && board[fromRow][fromCol + 2] === null && !isSquareAttacked(board, fromRow, fromCol + 1, piece.color) && !isSquareAttacked(board, fromRow, fromCol + 2, piece.color);\n    }\n\n    // Queenside castling\n    if (toCol === fromCol - 2 && (piece.color === 'white' && castlingRights.whiteQueenside || piece.color === 'black' && castlingRights.blackQueenside)) {\n      // Check if path is clear\n      return board[fromRow][fromCol - 1] === null && board[fromRow][fromCol - 2] === null && board[fromRow][fromCol - 3] === null && !isSquareAttacked(board, fromRow, fromCol - 1, piece.color) && !isSquareAttacked(board, fromRow, fromCol - 2, piece.color);\n    }\n  }\n  return false;\n};\n\n// Helper function to check if path between two positions is clear\nexport const isPathClear = (board, fromRow, fromCol, toRow, toCol) => {\n  const rowStep = fromRow === toRow ? 0 : toRow > fromRow ? 1 : -1;\n  const colStep = fromCol === toCol ? 0 : toCol > fromCol ? 1 : -1;\n  let currentRow = fromRow + rowStep;\n  let currentCol = fromCol + colStep;\n  while (currentRow !== toRow || currentCol !== toCol) {\n    if (board[currentRow][currentCol] !== null) {\n      return false;\n    }\n    currentRow += rowStep;\n    currentCol += colStep;\n  }\n  return true;\n};\n\n// Check if a square is under attack by opponent pieces\nexport const isSquareAttacked = (board, row, col, defendingColor) => {\n  const attackingColor = defendingColor === 'white' ? 'black' : 'white';\n\n  // Check for attacks by pawns\n  const pawnDirection = defendingColor === 'white' ? 1 : -1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0 && board[row + pawnDirection][col - 1] && board[row + pawnDirection][col - 1].type === 'pawn' && board[row + pawnDirection][col - 1].color === attackingColor) {\n      return true;\n    }\n    if (col + 1 < 8 && board[row + pawnDirection][col + 1] && board[row + pawnDirection][col + 1].type === 'pawn' && board[row + pawnDirection][col + 1].color === attackingColor) {\n      return true;\n    }\n  }\n\n  // Check for attacks by knights\n  const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && board[newRow][newCol] && board[newRow][newCol].type === 'knight' && board[newRow][newCol].color === attackingColor) {\n      return true;\n    }\n  }\n\n  // Check for attacks by bishops, rooks, and queens\n  const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      if (board[newRow][newCol]) {\n        if (board[newRow][newCol].color === attackingColor) {\n          const pieceType = board[newRow][newCol].type;\n\n          // Bishop attacks diagonally\n          if ((pieceType === 'bishop' || pieceType === 'queen') && Math.abs(rowDir) === Math.abs(colDir)) {\n            return true;\n          }\n\n          // Rook attacks horizontally and vertically\n          if ((pieceType === 'rook' || pieceType === 'queen') && (rowDir === 0 || colDir === 0)) {\n            return true;\n          }\n\n          // King attacks one square in any direction\n          if (pieceType === 'king' && Math.abs(newRow - row) <= 1 && Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return false;\n};\n\n// Check if a king is in check\nexport const isKingInCheck = (board, kingColor) => {\n  // Find the king's position\n  let kingRow = -1;\n  let kingCol = -1;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] && board[row][col].type === 'king' && board[row][col].color === kingColor) {\n        kingRow = row;\n        kingCol = col;\n        break;\n      }\n    }\n    if (kingRow !== -1) break;\n  }\n\n  // Check if the king's square is under attack\n  return isSquareAttacked(board, kingRow, kingCol, kingColor);\n};\n\n// Check if a move would put or leave the king in check\nexport const wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, kingColor) => {\n  // Create a copy of the board to simulate the move\n  const newBoard = board.map(row => [...row]);\n\n  // Simulate the move\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n\n  // Check if the king is in check after the move\n  return isKingInCheck(newBoard, kingColor);\n};\n\n// Check if the game is in checkmate\nexport const isCheckmate = (board, kingColor, castlingRights, lastMove) => {\n  // If the king is not in check, it's not checkmate\n  if (!isKingInCheck(board, kingColor)) {\n    return false;\n  }\n\n  // Check if any legal move can get the king out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === kingColor) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would get the king out of check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, kingColor)) {\n                return false; // Found a legal move that escapes check\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // No legal moves to escape check\n  return true;\n};\n\n// Check if the game is in stalemate\nexport const isStalemate = (board, kingColor, castlingRights, lastMove) => {\n  // If the king is in check, it's not stalemate\n  if (isKingInCheck(board, kingColor)) {\n    return false;\n  }\n\n  // Check if any legal move is available\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === kingColor) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, kingColor)) {\n                return false; // Found a legal move\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // No legal moves available\n  return true;\n};\n\n// Handle pawn promotion\nexport const canPromotePawn = (piece, toRow) => {\n  if (piece.type !== 'pawn') return false;\n\n  // Pawns promote when they reach the opposite end of the board\n  return piece.color === 'white' && toRow === 0 || piece.color === 'black' && toRow === 7;\n};\n\n// Handle castling\nexport const getCastlingMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Check if it's a castling move\n  if (board[fromRow][fromCol].type === 'king' && Math.abs(toCol - fromCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      return {\n        rookFromRow: fromRow,\n        rookFromCol: 7,\n        rookToRow: fromRow,\n        rookToCol: fromCol + 1\n      };\n    }\n    // Queenside castling\n    else {\n      return {\n        rookFromRow: fromRow,\n        rookFromCol: 0,\n        rookToRow: fromRow,\n        rookToCol: fromCol - 1\n      };\n    }\n  }\n  return null;\n};\n\n// Handle en passant capture\nexport const getEnPassantCapture = (board, fromRow, fromCol, toRow, toCol, lastMove) => {\n  const piece = board[fromRow][fromCol];\n  if (piece.type === 'pawn' && Math.abs(toCol - fromCol) === 1 && board[toRow][toCol] === null) {\n    // Check if it matches en passant conditions\n    if (lastMove && lastMove.piece.type === 'pawn' && lastMove.to.row === fromRow && lastMove.to.col === toCol && Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n      return {\n        captureRow: fromRow,\n        captureCol: toCol\n      };\n    }\n  }\n  return null;\n};\n\n// Update castling rights after a move\nexport const updateCastlingRights = (castlingRights, piece, fromRow, fromCol) => {\n  if (!castlingRights) return castlingRights;\n  const newRights = {\n    ...castlingRights\n  };\n\n  // If king moves, remove both castling rights for that color\n  if (piece.type === 'king') {\n    if (piece.color === 'white') {\n      newRights.whiteKingside = false;\n      newRights.whiteQueenside = false;\n    } else {\n      newRights.blackKingside = false;\n      newRights.blackQueenside = false;\n    }\n  }\n\n  // If rook moves, remove the corresponding castling right\n  if (piece.type === 'rook') {\n    if (piece.color === 'white') {\n      if (fromRow === 7 && fromCol === 0) newRights.whiteQueenside = false;\n      if (fromRow === 7 && fromCol === 7) newRights.whiteKingside = false;\n    } else {\n      if (fromRow === 0 && fromCol === 0) newRights.blackQueenside = false;\n      if (fromRow === 0 && fromCol === 7) newRights.blackKingside = false;\n    }\n  }\n  return newRights;\n};","map":{"version":3,"names":["isValidMove","board","fromRow","fromCol","toRow","toCol","piece","color","type","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","lastMove","direction","startingRow","Math","abs","to","row","col","from","isPathClear","rowDiff","colDiff","castlingRights","inCheck","whiteKingside","blackKingside","isSquareAttacked","whiteQueenside","blackQueenside","rowStep","colStep","currentRow","currentCol","defendingColor","attackingColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","pieceType","isKingInCheck","kingColor","kingRow","kingCol","wouldBeInCheck","newBoard","map","isCheckmate","isStalemate","canPromotePawn","getCastlingMove","rookFromRow","rookFromCol","rookToRow","rookToCol","getEnPassantCapture","captureRow","captureCol","updateCastlingRights","newRights"],"sources":["C:/Users/aksha/AppData/Local/Programs/Microsoft VS Code/chess-app/src/utils/chessRules.js"],"sourcesContent":["/**\n * Chess rules utility functions\n * Handles move validation, special moves, and game state checks\n */\n\n// Check if a move is valid based on piece type and chess rules\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n  \n  // Cannot capture own piece\n  if (board[toRow][toCol] && board[toRow][toCol].color === piece.color) {\n    return false;\n  }\n  \n  // Check specific piece movement rules\n  switch (piece.type) {\n    case 'pawn':\n      return isValidPawnMove(board, fromRow, fromCol, toRow, toCol);\n    case 'rook':\n      return isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n    case 'knight':\n      return isValidKnightMove(fromRow, fromCol, toRow, toCol);\n    case 'bishop':\n      return isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n    case 'queen':\n      return isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n    case 'king':\n      return isValidKingMove(board, fromRow, fromCol, toRow, toCol);\n    default:\n      return false;\n  }\n};\n\n// Pawn movement validation including en passant\nexport const isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, lastMove = null) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1; // White moves up (-1), black moves down (+1)\n  \n  // Regular move forward\n  if (fromCol === toCol && board[toRow][toCol] === null) {\n    // Move one square forward\n    if (toRow === fromRow + direction) {\n      return true;\n    }\n    \n    // Move two squares forward from starting position\n    const startingRow = piece.color === 'white' ? 6 : 1;\n    if (fromRow === startingRow && toRow === fromRow + 2 * direction && board[fromRow + direction][fromCol] === null) {\n      return true;\n    }\n  }\n  \n  // Capture diagonally\n  if (toRow === fromRow + direction && Math.abs(toCol - fromCol) === 1) {\n    // Regular capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (lastMove && \n        lastMove.piece.type === 'pawn' && \n        lastMove.to.row === fromRow && \n        lastMove.to.col === toCol && \n        Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Rook movement validation\nexport const isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rook can only move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) {\n    return false;\n  }\n  \n  // Check if path is clear\n  return isPathClear(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Knight movement validation\nexport const isValidKnightMove = (fromRow, fromCol, toRow, toCol) => {\n  // Knight moves in L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Bishop movement validation\nexport const isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishop can only move diagonally\n  if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) {\n    return false;\n  }\n  \n  // Check if path is clear\n  return isPathClear(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Queen movement validation\nexport const isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queen can move like a rook or a bishop\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// King movement validation including castling\nexport const isValidKingMove = (board, fromRow, fromCol, toRow, toCol, castlingRights = null, inCheck = false) => {\n  // Regular king move (one square in any direction)\n  const rowDiff = Math.abs(toRow - fromRow);\n  const colDiff = Math.abs(toCol - fromCol);\n  \n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (castlingRights && !inCheck && rowDiff === 0 && colDiff === 2) {\n    const piece = board[fromRow][fromCol];\n    \n    // Kingside castling\n    if (toCol === fromCol + 2 && \n        ((piece.color === 'white' && castlingRights.whiteKingside) || \n         (piece.color === 'black' && castlingRights.blackKingside))) {\n      // Check if path is clear\n      return board[fromRow][fromCol + 1] === null && \n             board[fromRow][fromCol + 2] === null && \n             !isSquareAttacked(board, fromRow, fromCol + 1, piece.color) &&\n             !isSquareAttacked(board, fromRow, fromCol + 2, piece.color);\n    }\n    \n    // Queenside castling\n    if (toCol === fromCol - 2 && \n        ((piece.color === 'white' && castlingRights.whiteQueenside) || \n         (piece.color === 'black' && castlingRights.blackQueenside))) {\n      // Check if path is clear\n      return board[fromRow][fromCol - 1] === null && \n             board[fromRow][fromCol - 2] === null && \n             board[fromRow][fromCol - 3] === null && \n             !isSquareAttacked(board, fromRow, fromCol - 1, piece.color) &&\n             !isSquareAttacked(board, fromRow, fromCol - 2, piece.color);\n    }\n  }\n  \n  return false;\n};\n\n// Helper function to check if path between two positions is clear\nexport const isPathClear = (board, fromRow, fromCol, toRow, toCol) => {\n  const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);\n  const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);\n  \n  let currentRow = fromRow + rowStep;\n  let currentCol = fromCol + colStep;\n  \n  while (currentRow !== toRow || currentCol !== toCol) {\n    if (board[currentRow][currentCol] !== null) {\n      return false;\n    }\n    currentRow += rowStep;\n    currentCol += colStep;\n  }\n  \n  return true;\n};\n\n// Check if a square is under attack by opponent pieces\nexport const isSquareAttacked = (board, row, col, defendingColor) => {\n  const attackingColor = defendingColor === 'white' ? 'black' : 'white';\n  \n  // Check for attacks by pawns\n  const pawnDirection = defendingColor === 'white' ? 1 : -1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0 && \n        board[row + pawnDirection][col - 1] && \n        board[row + pawnDirection][col - 1].type === 'pawn' && \n        board[row + pawnDirection][col - 1].color === attackingColor) {\n      return true;\n    }\n    if (col + 1 < 8 && \n        board[row + pawnDirection][col + 1] && \n        board[row + pawnDirection][col + 1].type === 'pawn' && \n        board[row + pawnDirection][col + 1].color === attackingColor) {\n      return true;\n    }\n  }\n  \n  // Check for attacks by knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8 && \n        board[newRow][newCol] && \n        board[newRow][newCol].type === 'knight' && \n        board[newRow][newCol].color === attackingColor) {\n      return true;\n    }\n  }\n  \n  // Check for attacks by bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      if (board[newRow][newCol]) {\n        if (board[newRow][newCol].color === attackingColor) {\n          const pieceType = board[newRow][newCol].type;\n          \n          // Bishop attacks diagonally\n          if ((pieceType === 'bishop' || pieceType === 'queen') && \n              Math.abs(rowDir) === Math.abs(colDir)) {\n            return true;\n          }\n          \n          // Rook attacks horizontally and vertically\n          if ((pieceType === 'rook' || pieceType === 'queen') && \n              (rowDir === 0 || colDir === 0)) {\n            return true;\n          }\n          \n          // King attacks one square in any direction\n          if (pieceType === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a king is in check\nexport const isKingInCheck = (board, kingColor) => {\n  // Find the king's position\n  let kingRow = -1;\n  let kingCol = -1;\n  \n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] && \n          board[row][col].type === 'king' && \n          board[row][col].color === kingColor) {\n        kingRow = row;\n        kingCol = col;\n        break;\n      }\n    }\n    if (kingRow !== -1) break;\n  }\n  \n  // Check if the king's square is under attack\n  return isSquareAttacked(board, kingRow, kingCol, kingColor);\n};\n\n// Check if a move would put or leave the king in check\nexport const wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, kingColor) => {\n  // Create a copy of the board to simulate the move\n  const newBoard = board.map(row => [...row]);\n  \n  // Simulate the move\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isKingInCheck(newBoard, kingColor);\n};\n\n// Check if the game is in checkmate\nexport const isCheckmate = (board, kingColor, castlingRights, lastMove) => {\n  // If the king is not in check, it's not checkmate\n  if (!isKingInCheck(board, kingColor)) {\n    return false;\n  }\n  \n  // Check if any legal move can get the king out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === kingColor) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would get the king out of check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, kingColor)) {\n                return false; // Found a legal move that escapes check\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // No legal moves to escape check\n  return true;\n};\n\n// Check if the game is in stalemate\nexport const isStalemate = (board, kingColor, castlingRights, lastMove) => {\n  // If the king is in check, it's not stalemate\n  if (isKingInCheck(board, kingColor)) {\n    return false;\n  }\n  \n  // Check if any legal move is available\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === kingColor) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, kingColor)) {\n                return false; // Found a legal move\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // No legal moves available\n  return true;\n};\n\n// Handle pawn promotion\nexport const canPromotePawn = (piece, toRow) => {\n  if (piece.type !== 'pawn') return false;\n  \n  // Pawns promote when they reach the opposite end of the board\n  return (piece.color === 'white' && toRow === 0) || \n         (piece.color === 'black' && toRow === 7);\n};\n\n// Handle castling\nexport const getCastlingMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Check if it's a castling move\n  if (board[fromRow][fromCol].type === 'king' && Math.abs(toCol - fromCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      return {\n        rookFromRow: fromRow,\n        rookFromCol: 7,\n        rookToRow: fromRow,\n        rookToCol: fromCol + 1\n      };\n    }\n    // Queenside castling\n    else {\n      return {\n        rookFromRow: fromRow,\n        rookFromCol: 0,\n        rookToRow: fromRow,\n        rookToCol: fromCol - 1\n      };\n    }\n  }\n  \n  return null;\n};\n\n// Handle en passant capture\nexport const getEnPassantCapture = (board, fromRow, fromCol, toRow, toCol, lastMove) => {\n  const piece = board[fromRow][fromCol];\n  \n  if (piece.type === 'pawn' && \n      Math.abs(toCol - fromCol) === 1 && \n      board[toRow][toCol] === null) {\n    // Check if it matches en passant conditions\n    if (lastMove && \n        lastMove.piece.type === 'pawn' && \n        lastMove.to.row === fromRow && \n        lastMove.to.col === toCol && \n        Math.abs(lastMove.from.row - lastMove.to.row) === 2) {\n      return { captureRow: fromRow, captureCol: toCol };\n    }\n  }\n  \n  return null;\n};\n\n// Update castling rights after a move\nexport const updateCastlingRights = (castlingRights, piece, fromRow, fromCol) => {\n  if (!castlingRights) return castlingRights;\n  \n  const newRights = { ...castlingRights };\n  \n  // If king moves, remove both castling rights for that color\n  if (piece.type === 'king') {\n    if (piece.color === 'white') {\n      newRights.whiteKingside = false;\n      newRights.whiteQueenside = false;\n    } else {\n      newRights.blackKingside = false;\n      newRights.blackQueenside = false;\n    }\n  }\n  \n  // If rook moves, remove the corresponding castling right\n  if (piece.type === 'rook') {\n    if (piece.color === 'white') {\n      if (fromRow === 7 && fromCol === 0) newRights.whiteQueenside = false;\n      if (fromRow === 7 && fromCol === 7) newRights.whiteKingside = false;\n    } else {\n      if (fromRow === 0 && fromCol === 0) newRights.blackQueenside = false;\n      if (fromRow === 0 && fromCol === 7) newRights.blackKingside = false;\n    }\n  }\n  \n  return newRights;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}