{"ast":null,"code":"/**\n * AI player for chess game\n * Implements a simple minimax algorithm with alpha-beta pruning\n */\n\nimport { isValidMove, wouldBeInCheck, isCheckmate, isStalemate } from './chessRules';\n\n// Piece values for evaluation\nconst PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// Position bonuses to encourage good piece positioning\nconst POSITION_BONUSES = {\n  pawn: [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5], [0.5, 1, 1, -2, -2, 1, 1, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]],\n  knight: [[-5, -4, -3, -3, -3, -3, -4, -5], [-4, -2, 0, 0, 0, 0, -2, -4], [-3, 0, 1, 1.5, 1.5, 1, 0, -3], [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3], [-3, 0, 1.5, 2, 2, 1.5, 0, -3], [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3], [-4, -2, 0, 0.5, 0.5, 0, -2, -4], [-5, -4, -3, -3, -3, -3, -4, -5]],\n  bishop: [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]],\n  rook: [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]],\n  queen: [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]],\n  king: [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]]\n};\n\n// Evaluate the board position from the perspective of the given color\nexport const evaluateBoard = (board, color) => {\n  let score = 0;\n\n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        // Material value\n        const materialValue = PIECE_VALUES[piece.type];\n\n        // Position bonus\n        let positionBonus = 0;\n        if (POSITION_BONUSES[piece.type]) {\n          // For black pieces, we need to flip the position matrix\n          const positionRow = piece.color === 'white' ? row : 7 - row;\n          positionBonus = POSITION_BONUSES[piece.type][positionRow][col];\n        }\n\n        // Add or subtract based on piece color\n        const value = materialValue + positionBonus;\n        if (piece.color === color) {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  return score;\n};\n\n// Get all valid moves for a given color\nexport const getAllValidMoves = (board, color, castlingRights, lastMove) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, color)) {\n                moves.push({\n                  fromRow,\n                  fromCol,\n                  toRow,\n                  toCol,\n                  piece\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Make a move on a copy of the board\nexport const makeMove = (board, move) => {\n  const newBoard = board.map(row => [...row]);\n  newBoard[move.toRow][move.toCol] = newBoard[move.fromRow][move.fromCol];\n  newBoard[move.fromRow][move.fromCol] = null;\n  return newBoard;\n};\n\n// Minimax algorithm with alpha-beta pruning\nexport const minimax = (board, depth, alpha, beta, maximizingPlayer, color, castlingRights, lastMove) => {\n  // Base case: reached maximum depth or game over\n  if (depth === 0) {\n    return {\n      score: evaluateBoard(board, color)\n    };\n  }\n  const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n\n  // Check for checkmate or stalemate\n  if (isCheckmate(board, currentColor, castlingRights, lastMove)) {\n    return {\n      score: maximizingPlayer ? -10000 : 10000\n    };\n  }\n  if (isStalemate(board, currentColor, castlingRights, lastMove)) {\n    return {\n      score: 0\n    };\n  }\n  const moves = getAllValidMoves(board, currentColor, castlingRights, lastMove);\n\n  // No valid moves\n  if (moves.length === 0) {\n    return {\n      score: evaluateBoard(board, color)\n    };\n  }\n  let bestMove = null;\n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, false, color, castlingRights, move);\n      if (evalResult.score > maxEval) {\n        maxEval = evalResult.score;\n        bestMove = move;\n      }\n      alpha = Math.max(alpha, evalResult.score);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    return {\n      move: bestMove,\n      score: maxEval\n    };\n  } else {\n    let minEval = Infinity;\n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, true, color, castlingRights, move);\n      if (evalResult.score < minEval) {\n        minEval = evalResult.score;\n        bestMove = move;\n      }\n      beta = Math.min(beta, evalResult.score);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    return {\n      move: bestMove,\n      score: minEval\n    };\n  }\n};\n\n// Get the best move for the AI\nexport const getBestMove = (board, color, castlingRights, lastMove, difficulty = 'medium') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 2;\n      break;\n    case 'medium':\n      depth = 3;\n      break;\n    case 'hard':\n      depth = 4;\n      break;\n    default:\n      depth = 3;\n  }\n\n  // Use minimax to find the best move\n  const result = minimax(board, depth, -Infinity, Infinity, true, color, castlingRights, lastMove);\n  return result.move;\n};","map":{"version":3,"names":["isValidMove","wouldBeInCheck","isCheckmate","isStalemate","PIECE_VALUES","pawn","knight","bishop","rook","queen","king","POSITION_BONUSES","evaluateBoard","board","color","score","row","col","piece","materialValue","type","positionBonus","positionRow","value","getAllValidMoves","castlingRights","lastMove","moves","fromRow","fromCol","toRow","toCol","push","makeMove","move","newBoard","map","minimax","depth","alpha","beta","maximizingPlayer","currentColor","length","bestMove","maxEval","Infinity","evalResult","Math","max","minEval","min","getBestMove","difficulty","result"],"sources":["C:/Users/aksha/AppData/Local/Programs/Microsoft VS Code/chess-app/src/utils/aiPlayer.js"],"sourcesContent":["/**\n * AI player for chess game\n * Implements a simple minimax algorithm with alpha-beta pruning\n */\n\nimport { isValidMove, wouldBeInCheck, isCheckmate, isStalemate } from './chessRules';\n\n// Piece values for evaluation\nconst PIECE_VALUES = {\n  pawn: 10,\n  knight: 30,\n  bishop: 30,\n  rook: 50,\n  queen: 90,\n  king: 900\n};\n\n// Position bonuses to encourage good piece positioning\nconst POSITION_BONUSES = {\n  pawn: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  knight: [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  bishop: [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  rook: [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  queen: [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  king: [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Evaluate the board position from the perspective of the given color\nexport const evaluateBoard = (board, color) => {\n  let score = 0;\n  \n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        // Material value\n        const materialValue = PIECE_VALUES[piece.type];\n        \n        // Position bonus\n        let positionBonus = 0;\n        if (POSITION_BONUSES[piece.type]) {\n          // For black pieces, we need to flip the position matrix\n          const positionRow = piece.color === 'white' ? row : 7 - row;\n          positionBonus = POSITION_BONUSES[piece.type][positionRow][col];\n        }\n        \n        // Add or subtract based on piece color\n        const value = materialValue + positionBonus;\n        if (piece.color === color) {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  \n  return score;\n};\n\n// Get all valid moves for a given color\nexport const getAllValidMoves = (board, color, castlingRights, lastMove) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if the move is valid according to piece rules\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol)) {\n              // Check if the move would not put the king in check\n              if (!wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, color)) {\n                moves.push({\n                  fromRow,\n                  fromCol,\n                  toRow,\n                  toCol,\n                  piece\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Make a move on a copy of the board\nexport const makeMove = (board, move) => {\n  const newBoard = board.map(row => [...row]);\n  newBoard[move.toRow][move.toCol] = newBoard[move.fromRow][move.fromCol];\n  newBoard[move.fromRow][move.fromCol] = null;\n  return newBoard;\n};\n\n// Minimax algorithm with alpha-beta pruning\nexport const minimax = (board, depth, alpha, beta, maximizingPlayer, color, castlingRights, lastMove) => {\n  // Base case: reached maximum depth or game over\n  if (depth === 0) {\n    return { score: evaluateBoard(board, color) };\n  }\n  \n  const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n  \n  // Check for checkmate or stalemate\n  if (isCheckmate(board, currentColor, castlingRights, lastMove)) {\n    return { score: maximizingPlayer ? -10000 : 10000 };\n  }\n  \n  if (isStalemate(board, currentColor, castlingRights, lastMove)) {\n    return { score: 0 };\n  }\n  \n  const moves = getAllValidMoves(board, currentColor, castlingRights, lastMove);\n  \n  // No valid moves\n  if (moves.length === 0) {\n    return { score: evaluateBoard(board, color) };\n  }\n  \n  let bestMove = null;\n  \n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    \n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, false, color, castlingRights, move);\n      \n      if (evalResult.score > maxEval) {\n        maxEval = evalResult.score;\n        bestMove = move;\n      }\n      \n      alpha = Math.max(alpha, evalResult.score);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    \n    return { move: bestMove, score: maxEval };\n  } else {\n    let minEval = Infinity;\n    \n    for (const move of moves) {\n      const newBoard = makeMove(board, move);\n      const evalResult = minimax(newBoard, depth - 1, alpha, beta, true, color, castlingRights, move);\n      \n      if (evalResult.score < minEval) {\n        minEval = evalResult.score;\n        bestMove = move;\n      }\n      \n      beta = Math.min(beta, evalResult.score);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    \n    return { move: bestMove, score: minEval };\n  }\n};\n\n// Get the best move for the AI\nexport const getBestMove = (board, color, castlingRights, lastMove, difficulty = 'medium') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 2;\n      break;\n    case 'medium':\n      depth = 3;\n      break;\n    case 'hard':\n      depth = 4;\n      break;\n    default:\n      depth = 3;\n  }\n  \n  // Use minimax to find the best move\n  const result = minimax(board, depth, -Infinity, Infinity, true, color, castlingRights, lastMove);\n  return result.move;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}